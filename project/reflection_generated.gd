# automatically generated by the FlatBuffers compiler, do not modify


class_name reflection
enum BaseType {
	NONE = 0,
	UTYPE = 1,
	BOOL = 2,
	BYTE = 3,
	UBYTE = 4,
	SHORT = 5,
	USHORT = 6,
	INT = 7,
	UINT = 8,
	LONG = 9,
	ULONG = 10,
	FLOAT = 11,
	DOUBLE = 12,
	STRING = 13,
	VECTOR = 14,
	OBJ = 15,
	UNION = 16,
	ARRAY = 17,
	MAXBASETYPE = 18
}

#/// New schema language features that are not supported by old code generators.
enum AdvancedFeatures {
	ADVANCEDARRAYFEATURES = 1,
	ADVANCEDUNIONFEATURES = 2,
	OPTIONALSCALARS = 4,
	DEFAULTVECTORSANDSTRINGS = 8
}

class FB_Type extends GD_FlatBuffer:
	static func GetType( _start : int, _bytes : PackedByteArray ) -> FB_Type:
		var new_Type = FB_Type.new()
		new_Type.start = _start
		new_Type.bytes = _bytes
		return new_Type

	enum {
		VT_BASE_TYPE = 4,
		VT_ELEMENT = 6,
		VT_INDEX = 8,
		VT_FIXED_LENGTH = 10,
		VT_BASE_SIZE = 12,
		VT_ELEMENT_SIZE = 14
	}

	func base_type_is_present() -> bool:
		return get_field_offset( VT_BASE_TYPE )

	func element_is_present() -> bool:
		return get_field_offset( VT_ELEMENT )

	func index_is_present() -> bool:
		return get_field_offset( VT_INDEX )

	func fixed_length_is_present() -> bool:
		return get_field_offset( VT_FIXED_LENGTH )

	func base_size_is_present() -> bool:
		return get_field_offset( VT_BASE_SIZE )

	func element_size_is_present() -> bool:
		return get_field_offset( VT_ELEMENT_SIZE )

	# base_type: BaseType
	func base_type() -> BaseType:
		var foffset = get_field_offset( VT_BASE_TYPE )
		if not foffset: return 0 as BaseType
		return decode_char( start + foffset ) as BaseType

	# element: BaseType
	func element() -> BaseType:
		var foffset = get_field_offset( VT_ELEMENT )
		if not foffset: return 0 as BaseType
		return decode_char( start + foffset ) as BaseType

	# index: int
	func index() -> int:
		var foffset = get_field_offset( VT_INDEX )
		if not foffset: return 0 as int
		return decode_int( start + foffset ) as int

	# fixed_length: int
	func fixed_length() -> int:
		var foffset = get_field_offset( VT_FIXED_LENGTH )
		if not foffset: return 0 as int
		return decode_ushort( start + foffset ) as int

	# base_size: int
	func base_size() -> int:
		var foffset = get_field_offset( VT_BASE_SIZE )
		if not foffset: return 0 as int
		return decode_uint( start + foffset ) as int

	# element_size: int
	func element_size() -> int:
		var foffset = get_field_offset( VT_ELEMENT_SIZE )
		if not foffset: return 0 as int
		return decode_uint( start + foffset ) as int


class FB_KeyValue extends GD_FlatBuffer:
	static func GetKeyValue( _start : int, _bytes : PackedByteArray ) -> FB_KeyValue:
		var new_KeyValue = FB_KeyValue.new()
		new_KeyValue.start = _start
		new_KeyValue.bytes = _bytes
		return new_KeyValue

	enum {
		VT_KEY = 4,
		VT_VALUE = 6
	}

	func key_is_present() -> bool:
		return get_field_offset( VT_KEY )

	func value_is_present() -> bool:
		return get_field_offset( VT_VALUE )

	# key: String
	func key() -> String:
		var foffset = get_field_offset( VT_KEY )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# value: String
	func value() -> String:
		var foffset = get_field_offset( VT_VALUE )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )


class FB_EnumVal extends GD_FlatBuffer:
	static func GetEnumVal( _start : int, _bytes : PackedByteArray ) -> FB_EnumVal:
		var new_EnumVal = FB_EnumVal.new()
		new_EnumVal.start = _start
		new_EnumVal.bytes = _bytes
		return new_EnumVal

	enum {
		VT_NAME = 4,
		VT_VALUE = 6,
		VT_UNION_TYPE = 10,
		VT_DOCUMENTATION = 12,
		VT_ATTRIBUTES = 14
	}

	func name_is_present() -> bool:
		return get_field_offset( VT_NAME )

	func value_is_present() -> bool:
		return get_field_offset( VT_VALUE )

	func union_type_is_present() -> bool:
		return get_field_offset( VT_UNION_TYPE )

	func documentation_is_present() -> bool:
		return get_field_offset( VT_DOCUMENTATION )

	func attributes_is_present() -> bool:
		return get_field_offset( VT_ATTRIBUTES )

	# name: String
	func name() -> String:
		var foffset = get_field_offset( VT_NAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# value: int
	func value() -> int:
		var foffset = get_field_offset( VT_VALUE )
		if not foffset: return 0 as int
		return decode_long( start + foffset ) as int

	# union_type: Type
	func union_type() -> FB_Type:
		var foffset = get_field_offset( VT_UNION_TYPE )
		if not foffset: return null
		return FB_Type.GetType( get_field_start(foffset), bytes )

	# documentation: Vector[string]
	func documentation_count() -> int:
		return get_array_count( VT_DOCUMENTATION )

	func documentation_get( index : int ) -> String:
		var foffset = get_field_offset( VT_DOCUMENTATION )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func documentation() -> FlatBuffer_Array:
		return get_array( VT_DOCUMENTATION, decode_string )


	# attributes: Vector[KeyValue]
	func attributes_count() -> int:
		return get_array_count( VT_ATTRIBUTES )

	# attributes: [KeyValue]
	func attributes_get( index : int ) -> FB_KeyValue:
		var foffset = get_field_offset( VT_ATTRIBUTES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_KeyValue.GetKeyValue( element_start, bytes )

	func attributes() -> FlatBuffer_Array:
		return get_array( VT_ATTRIBUTES, FB_KeyValue.GetKeyValue )



class FB_Enum extends GD_FlatBuffer:
	static func GetEnum( _start : int, _bytes : PackedByteArray ) -> FB_Enum:
		var new_Enum = FB_Enum.new()
		new_Enum.start = _start
		new_Enum.bytes = _bytes
		return new_Enum

	enum {
		VT_NAME = 4,
		VT_VALUES = 6,
		VT_IS_UNION = 8,
		VT_UNDERLYING_TYPE = 10,
		VT_ATTRIBUTES = 12,
		VT_DOCUMENTATION = 14,
		VT_DECLARATION_FILE = 16
	}

	func name_is_present() -> bool:
		return get_field_offset( VT_NAME )

	func values_is_present() -> bool:
		return get_field_offset( VT_VALUES )

	func is_union_is_present() -> bool:
		return get_field_offset( VT_IS_UNION )

	func underlying_type_is_present() -> bool:
		return get_field_offset( VT_UNDERLYING_TYPE )

	func attributes_is_present() -> bool:
		return get_field_offset( VT_ATTRIBUTES )

	func documentation_is_present() -> bool:
		return get_field_offset( VT_DOCUMENTATION )

	func declaration_file_is_present() -> bool:
		return get_field_offset( VT_DECLARATION_FILE )

	# name: String
	func name() -> String:
		var foffset = get_field_offset( VT_NAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# values: Vector[EnumVal]
	func values_count() -> int:
		return get_array_count( VT_VALUES )

	# values: [EnumVal]
	func values_get( index : int ) -> FB_EnumVal:
		var foffset = get_field_offset( VT_VALUES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_EnumVal.GetEnumVal( element_start, bytes )

	func values() -> FlatBuffer_Array:
		return get_array( VT_VALUES, FB_EnumVal.GetEnumVal )


	# is_union: bool
	func is_union() -> bool:
		var foffset = get_field_offset( VT_IS_UNION )
		if not foffset: return 0 as bool
		return decode_bool( start + foffset ) as bool

	# underlying_type: Type
	func underlying_type() -> FB_Type:
		var foffset = get_field_offset( VT_UNDERLYING_TYPE )
		if not foffset: return null
		return FB_Type.GetType( get_field_start(foffset), bytes )

	# attributes: Vector[KeyValue]
	func attributes_count() -> int:
		return get_array_count( VT_ATTRIBUTES )

	# attributes: [KeyValue]
	func attributes_get( index : int ) -> FB_KeyValue:
		var foffset = get_field_offset( VT_ATTRIBUTES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_KeyValue.GetKeyValue( element_start, bytes )

	func attributes() -> FlatBuffer_Array:
		return get_array( VT_ATTRIBUTES, FB_KeyValue.GetKeyValue )


	# documentation: Vector[string]
	func documentation_count() -> int:
		return get_array_count( VT_DOCUMENTATION )

	func documentation_get( index : int ) -> String:
		var foffset = get_field_offset( VT_DOCUMENTATION )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func documentation() -> FlatBuffer_Array:
		return get_array( VT_DOCUMENTATION, decode_string )


	# declaration_file: String
	func declaration_file() -> String:
		var foffset = get_field_offset( VT_DECLARATION_FILE )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )


class FB_Field extends GD_FlatBuffer:
	static func GetField( _start : int, _bytes : PackedByteArray ) -> FB_Field:
		var new_Field = FB_Field.new()
		new_Field.start = _start
		new_Field.bytes = _bytes
		return new_Field

	enum {
		VT_NAME = 4,
		VT_TYPE = 6,
		VT_ID = 8,
		VT_OFFSET = 10,
		VT_DEFAULT_INTEGER = 12,
		VT_DEFAULT_REAL = 14,
		VT_DEPRECATED = 16,
		VT_REQUIRED = 18,
		VT_KEY = 20,
		VT_ATTRIBUTES = 22,
		VT_DOCUMENTATION = 24,
		VT_OPTIONAL = 26,
		VT_PADDING = 28
	}

	func name_is_present() -> bool:
		return get_field_offset( VT_NAME )

	func type_is_present() -> bool:
		return get_field_offset( VT_TYPE )

	func id_is_present() -> bool:
		return get_field_offset( VT_ID )

	func offset_is_present() -> bool:
		return get_field_offset( VT_OFFSET )

	func default_integer_is_present() -> bool:
		return get_field_offset( VT_DEFAULT_INTEGER )

	func default_real_is_present() -> bool:
		return get_field_offset( VT_DEFAULT_REAL )

	func deprecated_is_present() -> bool:
		return get_field_offset( VT_DEPRECATED )

	func required_is_present() -> bool:
		return get_field_offset( VT_REQUIRED )

	func key_is_present() -> bool:
		return get_field_offset( VT_KEY )

	func attributes_is_present() -> bool:
		return get_field_offset( VT_ATTRIBUTES )

	func documentation_is_present() -> bool:
		return get_field_offset( VT_DOCUMENTATION )

	func optional_is_present() -> bool:
		return get_field_offset( VT_OPTIONAL )

	func padding_is_present() -> bool:
		return get_field_offset( VT_PADDING )

	# name: String
	func name() -> String:
		var foffset = get_field_offset( VT_NAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# type: Type
	func type() -> FB_Type:
		var foffset = get_field_offset( VT_TYPE )
		if not foffset: return null
		return FB_Type.GetType( get_field_start(foffset), bytes )

	# id: int
	func id() -> int:
		var foffset = get_field_offset( VT_ID )
		if not foffset: return 0 as int
		return decode_ushort( start + foffset ) as int

	# offset: int
	func offset() -> int:
		var foffset = get_field_offset( VT_OFFSET )
		if not foffset: return 0 as int
		return decode_ushort( start + foffset ) as int

	# default_integer: int
	func default_integer() -> int:
		var foffset = get_field_offset( VT_DEFAULT_INTEGER )
		if not foffset: return 0 as int
		return decode_long( start + foffset ) as int

	# default_real: float
	func default_real() -> float:
		var foffset = get_field_offset( VT_DEFAULT_REAL )
		if not foffset: return 0 as float
		return decode_double( start + foffset ) as float

	# deprecated: bool
	func deprecated() -> bool:
		var foffset = get_field_offset( VT_DEPRECATED )
		if not foffset: return 0 as bool
		return decode_bool( start + foffset ) as bool

	# required: bool
	func required() -> bool:
		var foffset = get_field_offset( VT_REQUIRED )
		if not foffset: return 0 as bool
		return decode_bool( start + foffset ) as bool

	# key: bool
	func key() -> bool:
		var foffset = get_field_offset( VT_KEY )
		if not foffset: return 0 as bool
		return decode_bool( start + foffset ) as bool

	# attributes: Vector[KeyValue]
	func attributes_count() -> int:
		return get_array_count( VT_ATTRIBUTES )

	# attributes: [KeyValue]
	func attributes_get( index : int ) -> FB_KeyValue:
		var foffset = get_field_offset( VT_ATTRIBUTES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_KeyValue.GetKeyValue( element_start, bytes )

	func attributes() -> FlatBuffer_Array:
		return get_array( VT_ATTRIBUTES, FB_KeyValue.GetKeyValue )


	# documentation: Vector[string]
	func documentation_count() -> int:
		return get_array_count( VT_DOCUMENTATION )

	func documentation_get( index : int ) -> String:
		var foffset = get_field_offset( VT_DOCUMENTATION )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func documentation() -> FlatBuffer_Array:
		return get_array( VT_DOCUMENTATION, decode_string )


	# optional: bool
	func optional() -> bool:
		var foffset = get_field_offset( VT_OPTIONAL )
		if not foffset: return 0 as bool
		return decode_bool( start + foffset ) as bool

	# padding: int
	func padding() -> int:
		var foffset = get_field_offset( VT_PADDING )
		if not foffset: return 0 as int
		return decode_ushort( start + foffset ) as int


class FB_Object extends GD_FlatBuffer:
	static func GetObject( _start : int, _bytes : PackedByteArray ) -> FB_Object:
		var new_Object = FB_Object.new()
		new_Object.start = _start
		new_Object.bytes = _bytes
		return new_Object

	enum {
		VT_NAME = 4,
		VT_FIELDS = 6,
		VT_IS_STRUCT = 8,
		VT_MINALIGN = 10,
		VT_BYTESIZE = 12,
		VT_ATTRIBUTES = 14,
		VT_DOCUMENTATION = 16,
		VT_DECLARATION_FILE = 18
	}

	func name_is_present() -> bool:
		return get_field_offset( VT_NAME )

	func fields_is_present() -> bool:
		return get_field_offset( VT_FIELDS )

	func is_struct_is_present() -> bool:
		return get_field_offset( VT_IS_STRUCT )

	func minalign_is_present() -> bool:
		return get_field_offset( VT_MINALIGN )

	func bytesize_is_present() -> bool:
		return get_field_offset( VT_BYTESIZE )

	func attributes_is_present() -> bool:
		return get_field_offset( VT_ATTRIBUTES )

	func documentation_is_present() -> bool:
		return get_field_offset( VT_DOCUMENTATION )

	func declaration_file_is_present() -> bool:
		return get_field_offset( VT_DECLARATION_FILE )

	# name: String
	func name() -> String:
		var foffset = get_field_offset( VT_NAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# fields: Vector[Field]
	func fields_count() -> int:
		return get_array_count( VT_FIELDS )

	# fields: [Field]
	func fields_get( index : int ) -> FB_Field:
		var foffset = get_field_offset( VT_FIELDS )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_Field.GetField( element_start, bytes )

	func fields() -> FlatBuffer_Array:
		return get_array( VT_FIELDS, FB_Field.GetField )


	# is_struct: bool
	func is_struct() -> bool:
		var foffset = get_field_offset( VT_IS_STRUCT )
		if not foffset: return 0 as bool
		return decode_bool( start + foffset ) as bool

	# minalign: int
	func minalign() -> int:
		var foffset = get_field_offset( VT_MINALIGN )
		if not foffset: return 0 as int
		return decode_int( start + foffset ) as int

	# bytesize: int
	func bytesize() -> int:
		var foffset = get_field_offset( VT_BYTESIZE )
		if not foffset: return 0 as int
		return decode_int( start + foffset ) as int

	# attributes: Vector[KeyValue]
	func attributes_count() -> int:
		return get_array_count( VT_ATTRIBUTES )

	# attributes: [KeyValue]
	func attributes_get( index : int ) -> FB_KeyValue:
		var foffset = get_field_offset( VT_ATTRIBUTES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_KeyValue.GetKeyValue( element_start, bytes )

	func attributes() -> FlatBuffer_Array:
		return get_array( VT_ATTRIBUTES, FB_KeyValue.GetKeyValue )


	# documentation: Vector[string]
	func documentation_count() -> int:
		return get_array_count( VT_DOCUMENTATION )

	func documentation_get( index : int ) -> String:
		var foffset = get_field_offset( VT_DOCUMENTATION )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func documentation() -> FlatBuffer_Array:
		return get_array( VT_DOCUMENTATION, decode_string )


	# declaration_file: String
	func declaration_file() -> String:
		var foffset = get_field_offset( VT_DECLARATION_FILE )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )


class FB_RPCCall extends GD_FlatBuffer:
	static func GetRPCCall( _start : int, _bytes : PackedByteArray ) -> FB_RPCCall:
		var new_RPCCall = FB_RPCCall.new()
		new_RPCCall.start = _start
		new_RPCCall.bytes = _bytes
		return new_RPCCall

	enum {
		VT_NAME = 4,
		VT_REQUEST = 6,
		VT_RESPONSE = 8,
		VT_ATTRIBUTES = 10,
		VT_DOCUMENTATION = 12
	}

	func name_is_present() -> bool:
		return get_field_offset( VT_NAME )

	func request_is_present() -> bool:
		return get_field_offset( VT_REQUEST )

	func response_is_present() -> bool:
		return get_field_offset( VT_RESPONSE )

	func attributes_is_present() -> bool:
		return get_field_offset( VT_ATTRIBUTES )

	func documentation_is_present() -> bool:
		return get_field_offset( VT_DOCUMENTATION )

	# name: String
	func name() -> String:
		var foffset = get_field_offset( VT_NAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# request: Object
	func request() -> FB_Object:
		var foffset = get_field_offset( VT_REQUEST )
		if not foffset: return null
		return FB_Object.GetObject( get_field_start(foffset), bytes )

	# response: Object
	func response() -> FB_Object:
		var foffset = get_field_offset( VT_RESPONSE )
		if not foffset: return null
		return FB_Object.GetObject( get_field_start(foffset), bytes )

	# attributes: Vector[KeyValue]
	func attributes_count() -> int:
		return get_array_count( VT_ATTRIBUTES )

	# attributes: [KeyValue]
	func attributes_get( index : int ) -> FB_KeyValue:
		var foffset = get_field_offset( VT_ATTRIBUTES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_KeyValue.GetKeyValue( element_start, bytes )

	func attributes() -> FlatBuffer_Array:
		return get_array( VT_ATTRIBUTES, FB_KeyValue.GetKeyValue )


	# documentation: Vector[string]
	func documentation_count() -> int:
		return get_array_count( VT_DOCUMENTATION )

	func documentation_get( index : int ) -> String:
		var foffset = get_field_offset( VT_DOCUMENTATION )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func documentation() -> FlatBuffer_Array:
		return get_array( VT_DOCUMENTATION, decode_string )



class FB_Service extends GD_FlatBuffer:
	static func GetService( _start : int, _bytes : PackedByteArray ) -> FB_Service:
		var new_Service = FB_Service.new()
		new_Service.start = _start
		new_Service.bytes = _bytes
		return new_Service

	enum {
		VT_NAME = 4,
		VT_CALLS = 6,
		VT_ATTRIBUTES = 8,
		VT_DOCUMENTATION = 10,
		VT_DECLARATION_FILE = 12
	}

	func name_is_present() -> bool:
		return get_field_offset( VT_NAME )

	func calls_is_present() -> bool:
		return get_field_offset( VT_CALLS )

	func attributes_is_present() -> bool:
		return get_field_offset( VT_ATTRIBUTES )

	func documentation_is_present() -> bool:
		return get_field_offset( VT_DOCUMENTATION )

	func declaration_file_is_present() -> bool:
		return get_field_offset( VT_DECLARATION_FILE )

	# name: String
	func name() -> String:
		var foffset = get_field_offset( VT_NAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# calls: Vector[RPCCall]
	func calls_count() -> int:
		return get_array_count( VT_CALLS )

	# calls: [RPCCall]
	func calls_get( index : int ) -> FB_RPCCall:
		var foffset = get_field_offset( VT_CALLS )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_RPCCall.GetRPCCall( element_start, bytes )

	func calls() -> FlatBuffer_Array:
		return get_array( VT_CALLS, FB_RPCCall.GetRPCCall )


	# attributes: Vector[KeyValue]
	func attributes_count() -> int:
		return get_array_count( VT_ATTRIBUTES )

	# attributes: [KeyValue]
	func attributes_get( index : int ) -> FB_KeyValue:
		var foffset = get_field_offset( VT_ATTRIBUTES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_KeyValue.GetKeyValue( element_start, bytes )

	func attributes() -> FlatBuffer_Array:
		return get_array( VT_ATTRIBUTES, FB_KeyValue.GetKeyValue )


	# documentation: Vector[string]
	func documentation_count() -> int:
		return get_array_count( VT_DOCUMENTATION )

	func documentation_get( index : int ) -> String:
		var foffset = get_field_offset( VT_DOCUMENTATION )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func documentation() -> FlatBuffer_Array:
		return get_array( VT_DOCUMENTATION, decode_string )


	# declaration_file: String
	func declaration_file() -> String:
		var foffset = get_field_offset( VT_DECLARATION_FILE )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )


#/// File specific information.
#/// Symbols declared within a file may be recovered by iterating over all
#/// symbols and examining the `declaration_file` field.
class FB_SchemaFile extends GD_FlatBuffer:
	static func GetSchemaFile( _start : int, _bytes : PackedByteArray ) -> FB_SchemaFile:
		var new_SchemaFile = FB_SchemaFile.new()
		new_SchemaFile.start = _start
		new_SchemaFile.bytes = _bytes
		return new_SchemaFile

	enum {
		VT_FILENAME = 4,
		VT_INCLUDED_FILENAMES = 6
	}

	func filename_is_present() -> bool:
		return get_field_offset( VT_FILENAME )

	func included_filenames_is_present() -> bool:
		return get_field_offset( VT_INCLUDED_FILENAMES )

	# filename: String
	func filename() -> String:
		var foffset = get_field_offset( VT_FILENAME )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# included_filenames: Vector[string]
	func included_filenames_count() -> int:
		return get_array_count( VT_INCLUDED_FILENAMES )

	func included_filenames_get( index : int ) -> String:
		var foffset = get_field_offset( VT_INCLUDED_FILENAMES )
		if not foffset: return ""
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return decode_string( element_start )

	func included_filenames() -> FlatBuffer_Array:
		return get_array( VT_INCLUDED_FILENAMES, decode_string )



class FB_Schema extends GD_FlatBuffer:
	static func GetSchema( _start : int, _bytes : PackedByteArray ) -> FB_Schema:
		var new_Schema = FB_Schema.new()
		new_Schema.start = _start
		new_Schema.bytes = _bytes
		return new_Schema

	enum {
		VT_OBJECTS = 4,
		VT_ENUMS = 6,
		VT_FILE_IDENT = 8,
		VT_FILE_EXT = 10,
		VT_ROOT_TABLE = 12,
		VT_SERVICES = 14,
		VT_ADVANCED_FEATURES = 16,
		VT_FBS_FILES = 18
	}

	func objects_is_present() -> bool:
		return get_field_offset( VT_OBJECTS )

	func enums_is_present() -> bool:
		return get_field_offset( VT_ENUMS )

	func file_ident_is_present() -> bool:
		return get_field_offset( VT_FILE_IDENT )

	func file_ext_is_present() -> bool:
		return get_field_offset( VT_FILE_EXT )

	func root_table_is_present() -> bool:
		return get_field_offset( VT_ROOT_TABLE )

	func services_is_present() -> bool:
		return get_field_offset( VT_SERVICES )

	func advanced_features_is_present() -> bool:
		return get_field_offset( VT_ADVANCED_FEATURES )

	func fbs_files_is_present() -> bool:
		return get_field_offset( VT_FBS_FILES )

	# objects: Vector[Object]
	func objects_count() -> int:
		return get_array_count( VT_OBJECTS )

	# objects: [Object]
	func objects_get( index : int ) -> FB_Object:
		var foffset = get_field_offset( VT_OBJECTS )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_Object.GetObject( element_start, bytes )

	func objects() -> FlatBuffer_Array:
		return get_array( VT_OBJECTS, FB_Object.GetObject )


	# enums: Vector[Enum]
	func enums_count() -> int:
		return get_array_count( VT_ENUMS )

	# enums: [Enum]
	func enums_get( index : int ) -> FB_Enum:
		var foffset = get_field_offset( VT_ENUMS )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_Enum.GetEnum( element_start, bytes )

	func enums() -> FlatBuffer_Array:
		return get_array( VT_ENUMS, FB_Enum.GetEnum )


	# file_ident: String
	func file_ident() -> String:
		var foffset = get_field_offset( VT_FILE_IDENT )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# file_ext: String
	func file_ext() -> String:
		var foffset = get_field_offset( VT_FILE_EXT )
		if not foffset: return ""
		return  decode_string( get_field_start( foffset ) )

	# root_table: Object
	func root_table() -> FB_Object:
		var foffset = get_field_offset( VT_ROOT_TABLE )
		if not foffset: return null
		return FB_Object.GetObject( get_field_start(foffset), bytes )

	# services: Vector[Service]
	func services_count() -> int:
		return get_array_count( VT_SERVICES )

	# services: [Service]
	func services_get( index : int ) -> FB_Service:
		var foffset = get_field_offset( VT_SERVICES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_Service.GetService( element_start, bytes )

	func services() -> FlatBuffer_Array:
		return get_array( VT_SERVICES, FB_Service.GetService )


	# advanced_features: AdvancedFeatures
	func advanced_features() -> AdvancedFeatures:
		var foffset = get_field_offset( VT_ADVANCED_FEATURES )
		if not foffset: return 0 as AdvancedFeatures
		return decode_ulong( start + foffset ) as AdvancedFeatures

	# fbs_files: Vector[SchemaFile]
	func fbs_files_count() -> int:
		return get_array_count( VT_FBS_FILES )

	# fbs_files: [SchemaFile]
	func fbs_files_get( index : int ) -> FB_SchemaFile:
		var foffset = get_field_offset( VT_FBS_FILES )
		if not foffset: return null
		var array_start = get_field_start( foffset )
		var element_start = get_array_element_start( array_start, index )
		return FB_SchemaFile.GetSchemaFile( element_start, bytes )

	func fbs_files() -> FlatBuffer_Array:
		return get_array( VT_FBS_FILES, FB_SchemaFile.GetSchemaFile )



