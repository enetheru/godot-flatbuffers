# automatically generated by the FlatBuffers compiler, do not modify

static func GetRoot( data : PackedByteArray ) -> RootTable:
	return GetRootTable( data.decode_u32(0), data )

static func GetSubTable( _start : int, _bytes : PackedByteArray ) -> SubTable:
	var new_SubTable = SubTable.new()
	new_SubTable.start = _start
	new_SubTable.bytes = _bytes
	return new_SubTable


class SubTable extends FlatBuffer:
	# table
	enum voffsets {
		VT_ITEM = 4
	}

	func item_is_present() -> bool:
		return get_field_offset( voffsets.VT_ITEM )

	func item() -> int:
		var foffset = get_field_offset( voffsets.VT_ITEM )
		if not foffset: return 0
		return bytes.decode_s32( start + foffset )

	func debug() -> Dictionary:
		var d : Dictionary = {}
		d['type'] = "SubTable"
		d['start'] = start
		d['vtable_offset'] = bytes.decode_s32( start )
		d['vtable_start'] = d.start - d.vtable_offset
		d['vtable_bytes'] = bytes.decode_u16( d.vtable_start )
		d['vtable'] = Dictionary()
		d.vtable['table_size'] = bytes.decode_u16( d.vtable_start + 2 )
		d.vtable['vtable_size'] = (d.vtable_bytes / 2) - 2
		for i in d.vtable.vtable_size:
			d.vtable[voffsets.keys()[i]] = bytes.decode_u16( d.vtable_start + voffsets.values()[i] )
		if item_is_present():
			var item = self.item()
			if item is FlatBuffer:
				d['item'] = item.debug()
			else:
				d['item'] = item()

		var item = self.item()
		if item is FlatBuffer: d['item'] = item.debug()
		else: d['item'] = item()
		return d

	func pprint( printer : FlatBufferPrinter, heading = ""):
		printer.print("SubTable {", heading)
		printer.indent()
		# item:int
		if item_is_present():
			printer.print( self.item(), "item" )
		printer.outdent()
		printer.print("}")


class SubTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_item( item : int ) -> void:
		fbb_.add_element_int_default( SubTable.voffsets.VT_ITEM, item, 0 )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;

static func CreateSubTable( _fbb : FlatBufferBuilder,
		item : int ) -> int :
	var builder = SubTableBuilder.new( _fbb );
	builder.add_item( item );
	return builder.finish();

static func CreateSubTable2( _fbb : FlatBufferBuilder, object : Variant ) -> int :
	var builder = SubTableBuilder.new( _fbb );
	builder.add_item( object.item );
	return builder.finish();

static func GetRootTable( _start : int, _bytes : PackedByteArray ) -> RootTable:
	var new_RootTable = RootTable.new()
	new_RootTable.start = _start
	new_RootTable.bytes = _bytes
	return new_RootTable


class RootTable extends FlatBuffer:
	var parent = load( 'res://tests/table_array/FBTestTableArray_old.gd' )
	# table
	enum {
		VT_TABLE_ARRAY = 4
	}
	enum voffsets {
		VT_TABLE_ARRAY = 4
	}

	func table_array_is_present() -> bool:
		return get_field_offset( VT_TABLE_ARRAY )

	# Accessors for table_array
	func table_array_size() -> int:
		return get_array_size( VT_TABLE_ARRAY )

	# TODO Unhandled array element type.
	func table_array() -> Array:
		var array : Dictionary = {}
		array['start'] = get_field_start( VT_TABLE_ARRAY )
		if not array.start: return []

		array['size'] = bytes.decode_u32( array.start )
		array['data'] = array.start + 4
		var starts : Array; starts.resize( array.size )
		var offsets : Array; offsets.resize( array.size )
		for i in array.size:
			var pos = array.data + i * 4
			offsets[i] = bytes.decode_u32( pos )
			starts[i] = pos + offsets[i]
		array['offsets'] = offsets
		array['starts'] = starts

		var subtables : Array; subtables.resize( array.size )
		for i in array.size:
			subtables[i] = parent.GetSubTable( starts[i], bytes )
		return subtables


	func debug():
		var d : Dictionary = {}
		d['type'] = "RootTable"
		d['start'] = start
		d['vtable_offset'] = bytes.decode_s32( start )
		d['vtable_start'] = d.start - d.vtable_offset

		d['vtable'] = Dictionary()
		d.vtable['vtable_bytes'] = bytes.decode_u16( d.vtable_start )
		d.vtable['table_bytes'] = bytes.decode_u16( d.vtable_start + 2 )
		for i in ((d.vtable.vtable_bytes / 2) - 2):
			d.vtable[voffsets.keys()[i]] = bytes.decode_u16( d.vtable_start + voffsets.values()[i] )
		# table_array:Array
		d['table_array'] = table_array().map( func( item ): return item.debug() )

		return d

	func pprint( printer : FlatBufferPrinter, heading = ""):
		printer.print("RootTable {", heading)
		printer.indent()
		# table_array:Array
		if table_array_is_present():
			printer.print( self.table_array(), "table_array" )
		printer.outdent()
		printer.print("}")


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_table_array( table_array_offset : int ) -> void:
		fbb_.add_offset( RootTable.VT_TABLE_ARRAY, table_array_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;

static func pretend_CreateTableArray( builder : FlatBufferBuilder, array : Array, constructor : Callable ) -> int:
	var offsets : PackedInt32Array
	offsets.resize( array.size() )
	for index in array.size():
		var object = array[index]
		print( "object.item: ", object.item )
		offsets[index] = constructor.call( builder, object.item )
	return builder.create_vector_offset( offsets )

static func CreateRootTable( _fbb : FlatBufferBuilder,
		table_array : Array ) -> int :

	var table_array_offset : int = _fbb.create_vector_table( table_array, CreateSubTable2 );
	print( table_array_offset)
	return 0

	#var builder = RootTableBuilder.new( _fbb );
	#builder.add_table_array( table_array_offset );
	#return builder.finish();
